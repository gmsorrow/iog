{"ast":null,"code":"import { AUTH_TOKEN_NAME, FETCH_TIMEOUT_MESSAGE, FETCH_TIMEOUT_MS, NETWORK_ISSUE_MESSAGES } from './constants';\nconst baseUrl = process.env.REACT_APP_BASE_URL;\nexport function executeRequest(url, options = {}, dontExtend) {\n  let extendedUrl = url;\n  const requestMethodType = (options === null || options === void 0 ? void 0 : options.method) || 'GET';\n\n  if (!url.includes('http') && !dontExtend) {\n    extendedUrl = `${baseUrl}/${url}`;\n  }\n\n  let defaultHeaders = {};\n\n  switch (requestMethodType) {\n    case 'GET':\n    case 'POST':\n    case 'PUT':\n    case 'DELETE':\n      defaultHeaders = {\n        Accept: 'application/json',\n        'Content-Type': 'application/json'\n      };\n      break;\n\n    default:\n      defaultHeaders = {};\n  }\n\n  const token = localStorage.getItem(AUTH_TOKEN_NAME);\n  let extendedOptions = { ...options,\n    headers: { ...options.headers,\n      ...defaultHeaders\n    }\n  };\n\n  if (token) {\n    extendedOptions = { ...extendedOptions,\n      headers: { ...extendedOptions.headers,\n        Authorization: `Bearer ${token}`\n      }\n    };\n  } // @ts-ignore\n\n\n  return requestWithTimeout(extendedUrl, extendedOptions).then(transformResponse);\n}\n\nconst transformResponse = response => new Promise(resolve => parseJSONFromFetch(response).then(json => {\n  if (response.status === 401) {\n    window.onbeforeunload = () => {}; // sign out attempt\n\n  }\n\n  return resolve({\n    status: response.status,\n    error: response.status < 200 || response.status > 299,\n    data: json\n  });\n}));\n\nconst parseJSONFromFetch = response => response.text().then(text => {\n  let data = null;\n\n  try {\n    data = text ? JSON.parse(text) : text;\n  } catch (err) {\n    data = text;\n  }\n\n  return data;\n});\n\nconst requestWithTimeout = async (url, extendedOptions) => {\n  const controller = new AbortController();\n  const extendedOptionsWithAbortController = {\n    signal: controller.signal,\n    timeout: null,\n    ...extendedOptions\n  };\n  const timeout = extendedOptionsWithAbortController.timeout || FETCH_TIMEOUT_MS;\n  let response;\n\n  try {\n    response = await Promise.race([fetch(url, extendedOptionsWithAbortController), new Promise((_, reject) => setTimeout(() => {\n      reject(new Error(FETCH_TIMEOUT_MESSAGE));\n    }, timeout))]);\n  } catch (error) {\n    if (NETWORK_ISSUE_MESSAGES.includes(error.message)) {\n      if (error.message === FETCH_TIMEOUT_MESSAGE) {\n        controller.abort();\n      }\n\n      throw new Error(error.message);\n    }\n\n    throw error;\n  }\n\n  return response;\n};","map":{"version":3,"sources":["C:/projects/iog/web/src/api/index.ts"],"names":["AUTH_TOKEN_NAME","FETCH_TIMEOUT_MESSAGE","FETCH_TIMEOUT_MS","NETWORK_ISSUE_MESSAGES","baseUrl","process","env","REACT_APP_BASE_URL","executeRequest","url","options","dontExtend","extendedUrl","requestMethodType","method","includes","defaultHeaders","Accept","token","localStorage","getItem","extendedOptions","headers","Authorization","requestWithTimeout","then","transformResponse","response","Promise","resolve","parseJSONFromFetch","json","status","window","onbeforeunload","error","data","text","JSON","parse","err","controller","AbortController","extendedOptionsWithAbortController","signal","timeout","race","fetch","_","reject","setTimeout","Error","message","abort"],"mappings":"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","sourcesContent":["import {\n  AUTH_TOKEN_NAME,\n  FETCH_TIMEOUT_MESSAGE,\n  FETCH_TIMEOUT_MS,\n  NETWORK_ISSUE_MESSAGES,\n} from './constants';\n\nconst baseUrl = process.env.REACT_APP_BASE_URL;\n\nexport type ApiResponse<Data> = {\n  status: number;\n  error: boolean;\n  data: Data;\n  text: Function;\n};\n\nexport function executeRequest<Data>(url: string, options: { [key: string]: any } = {}, dontExtend?: boolean): Promise<ApiResponse<Data>> {\n  let extendedUrl = url;\n  const requestMethodType = options?.method || 'GET';\n\n  if (!url.includes('http') && !dontExtend) {\n    extendedUrl = `${baseUrl}/${url}`;\n  }\n\n  let defaultHeaders = {};\n  switch (requestMethodType) {\n    case 'GET':\n    case 'POST':\n    case 'PUT':\n    case 'DELETE':\n      defaultHeaders = {\n        Accept: 'application/json',\n        'Content-Type': 'application/json',\n      };\n      break;\n    default:\n      defaultHeaders = {};\n  }\n\n  const token = localStorage.getItem(AUTH_TOKEN_NAME);\n\n  let extendedOptions = {\n    ...options,\n    headers: {\n      ...options.headers,\n      ...defaultHeaders,\n    },\n  };\n\n  if (token) {\n    extendedOptions = {\n      ...extendedOptions,\n      headers: {\n        ...extendedOptions.headers,\n        Authorization: `Bearer ${token}`,\n      },\n    };\n  }\n  // @ts-ignore\n  return requestWithTimeout(extendedUrl, extendedOptions).then(transformResponse);\n}\n\nconst transformResponse = (response: any) => new Promise(\n  (resolve) => parseJSONFromFetch(response)\n    .then((json: string) => {\n      if (response.status === 401) {\n        window.onbeforeunload = () => {};\n        // sign out attempt\n      }\n      return resolve({\n        status: response.status,\n        error: response.status < 200 || response.status > 299,\n        data: json,\n      });\n    })\n);\n\nconst parseJSONFromFetch = (response: any) => response.text().then((text: void | string) => {\n  let data = null;\n  try {\n    data = text ? JSON.parse(text) : text;\n  } catch (err) {\n    data = text;\n  }\n  return data;\n});\n\nconst requestWithTimeout = async (url: string, extendedOptions: { [key: string]: any }) => {\n  const controller = new AbortController();\n\n  const extendedOptionsWithAbortController = {\n    signal: controller.signal,\n    timeout: null,\n    ...extendedOptions,\n  };\n  const timeout = extendedOptionsWithAbortController.timeout || FETCH_TIMEOUT_MS;\n\n  let response;\n\n  try {\n    response = await Promise.race([fetch(url, extendedOptionsWithAbortController), new Promise((_, reject) => setTimeout(() => {\n      reject(new Error(FETCH_TIMEOUT_MESSAGE));\n    }, timeout))]);\n  } catch (error) {\n    if (NETWORK_ISSUE_MESSAGES.includes(error.message)) {\n      if (error.message === FETCH_TIMEOUT_MESSAGE) {\n        controller.abort();\n      }\n      throw new Error(error.message);\n    }\n    throw error;\n  }\n  return response;\n};\n"]},"metadata":{},"sourceType":"module"}